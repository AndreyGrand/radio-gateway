#include "ssd1306.h"
#include "driver/i2c_master.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include <string.h>

static const char *TAG = "ssd1306";

// 8x8 pixel font for ASCII 32-126
static const uint8_t font8x8[95][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // space
    {0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00}, // !
    {0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00}, // "
    {0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00}, // #
    {0x30, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x30, 0x00}, // $
    {0xC6, 0xC6, 0x0C, 0x18, 0x30, 0x66, 0xC6, 0x00}, // %
    {0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00}, // &
    {0x60, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00}, // '
    {0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00}, // (
    {0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00}, // )
    {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00}, // *
    {0x00, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x00, 0x00}, // +
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30}, // ,
    {0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00}, // -
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00}, // .
    {0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00}, // /
    {0x7C, 0xC6, 0xCE, 0xDE, 0xF6, 0xE6, 0x7C, 0x00}, // 0
    {0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00}, // 1
    {0x78, 0xCC, 0x0C, 0x38, 0x60, 0xCC, 0xFC, 0x00}, // 2
    {0x78, 0xCC, 0x0C, 0x38, 0x0C, 0xCC, 0x78, 0x00}, // 3
    {0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00}, // 4
    {0xFC, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00}, // 5
    {0x38, 0x60, 0xC0, 0xF8, 0xCC, 0xCC, 0x78, 0x00}, // 6
    {0xFC, 0xCC, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00}, // 7
    {0x78, 0xCC, 0xCC, 0x78, 0xCC, 0xCC, 0x78, 0x00}, // 8
    {0x78, 0xCC, 0xCC, 0x7C, 0x0C, 0x18, 0x70, 0x00}, // 9
    {0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00}, // :
    {0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30, 0x00}, // ;
    {0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00}, // <
    {0x00, 0x00, 0xFC, 0x00, 0xFC, 0x00, 0x00, 0x00}, // =
    {0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00}, // >
    {0x78, 0xCC, 0x0C, 0x18, 0x30, 0x00, 0x30, 0x00}, // ?
    {0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x78, 0x00}, // @
    {0x30, 0x78, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0x00}, // A
    {0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00}, // B
    {0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00}, // C
    {0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00}, // D
    {0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00}, // E
    {0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00}, // F
    {0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3E, 0x00}, // G
    {0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00}, // H
    {0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00}, // I
    {0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00}, // J
    {0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00}, // K
    {0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00}, // L
    {0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00}, // M
    {0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00}, // N
    {0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00}, // O
    {0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00}, // P
    {0x38, 0x6C, 0xC6, 0xC6, 0xCE, 0x6C, 0x3E, 0x06}, // Q
    {0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00}, // R
    {0x78, 0xCC, 0xC0, 0x78, 0x0C, 0xCC, 0x78, 0x00}, // S
    {0xFC, 0xB4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00}, // T
    {0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFC, 0x00}, // U
    {0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00}, // V
    {0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0xC6, 0x00}, // W
    {0xC6, 0x6C, 0x38, 0x30, 0x38, 0x6C, 0xC6, 0x00}, // X
    {0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x30, 0x78, 0x00}, // Y
    {0xFE, 0xCC, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00}, // Z
    {0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00}, // [
    {0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00}, // '\'
    {0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00}, // ]
    {0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00}, // ^
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF}, // _
    {0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00}, // `
    {0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00}, // a
    {0xE0, 0x60, 0x7C, 0x66, 0x66, 0x66, 0xDC, 0x00}, // b
    {0x00, 0x00, 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x00}, // c
    {0x1C, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00}, // d
    {0x00, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00}, // e
    {0x38, 0x6C, 0x60, 0xF0, 0x60, 0x60, 0xF0, 0x00}, // f
    {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8}, // g
    {0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00}, // h
    {0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00}, // i
    {0x0C, 0x00, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78}, // j
    {0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00}, // k
    {0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00}, // l
    {0x00, 0x00, 0xCC, 0xFE, 0xFE, 0xD6, 0xC6, 0x00}, // m
    {0x00, 0x00, 0xF8, 0xCC, 0xCC, 0xCC, 0xCC, 0x00}, // n
    {0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00}, // o
    {0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0}, // p
    {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E}, // q
    {0x00, 0x00, 0xDC, 0x76, 0x60, 0x60, 0xF0, 0x00}, // r
    {0x00, 0x00, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x00}, // s
    {0x10, 0x30, 0x7C, 0x30, 0x30, 0x34, 0x18, 0x00}, // t
    {0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00}, // u
    {0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00}, // v
    {0x00, 0x00, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00}, // w
    {0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00}, // x
    {0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8}, // y
    {0x00, 0x00, 0xFC, 0x98, 0x30, 0x64, 0xFC, 0x00}, // z
    {0x1C, 0x30, 0x30, 0xE0, 0x30, 0x30, 0x1C, 0x00}, // {
    {0x08, 0x08, 0x08, 0x00, 0x08, 0x08, 0x08, 0x00}, // |
    {0xE0, 0x30, 0x30, 0x1C, 0x30, 0x30, 0xE0, 0x00}, // }
    {0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // ~
};

#define I2C_PORT I2C_NUM_0
#define SDA_PIN 21
#define SCL_PIN 22
#define OLED_ADDR 0x3C

static uint8_t buffer[128 * 64 / 8];
static i2c_master_bus_handle_t bus_handle;
static i2c_master_dev_handle_t dev_handle;

static void i2c_write(uint8_t control, uint8_t data)
{
    uint8_t write_buffer[2] = {control, data};
    i2c_master_transmit(dev_handle, write_buffer, sizeof(write_buffer), -1);
}

static void ssd1306_cmd(uint8_t cmd) { i2c_write(0x00, cmd); }
static void ssd1306_data(uint8_t data) { i2c_write(0x40, data); }

void ssd1306_init(void)
{
    // Configure I2C bus
    i2c_master_bus_config_t bus_cfg = {
        .i2c_port = I2C_PORT,
        .sda_io_num = SDA_PIN,
        .scl_io_num = SCL_PIN,
        .clk_source = I2C_CLK_SRC_DEFAULT,
        .glitch_ignore_cnt = 7,
        .flags.enable_internal_pullup = true,
    };
    ESP_ERROR_CHECK(i2c_new_master_bus(&bus_cfg, &bus_handle));

    // Configure I2C device
    i2c_device_config_t dev_cfg = {
        .dev_addr_length = I2C_ADDR_BIT_LEN_7,
        .device_address = OLED_ADDR,
        .scl_speed_hz = 400000,
    };
    ESP_ERROR_CHECK(i2c_master_bus_add_device(bus_handle, &dev_cfg, &dev_handle));

    ssd1306_cmd(0xAE); ssd1306_cmd(0x20); ssd1306_cmd(0x00);
    ssd1306_cmd(0xB0); ssd1306_cmd(0xC8); ssd1306_cmd(0x00);
    ssd1306_cmd(0x10); ssd1306_cmd(0x40); ssd1306_cmd(0x81);
    ssd1306_cmd(0x7F); ssd1306_cmd(0xA1); ssd1306_cmd(0xA6);
    ssd1306_cmd(0xA8); ssd1306_cmd(0x3F); ssd1306_cmd(0xA4);
    ssd1306_cmd(0xD3); ssd1306_cmd(0x00); ssd1306_cmd(0xD5);
    ssd1306_cmd(0x80); ssd1306_cmd(0xD9); ssd1306_cmd(0xF1);
    ssd1306_cmd(0xDA); ssd1306_cmd(0x12); ssd1306_cmd(0xDB);
    ssd1306_cmd(0x40); ssd1306_cmd(0x8D); ssd1306_cmd(0x14);
    ssd1306_cmd(0xD5); ssd1306_cmd(0x80);  // Set display clock divide ratio
    ssd1306_cmd(0xDC); ssd1306_cmd(0x00);  // Set VCOMH deselect level
    ssd1306_cmd(0xA6);                     // Normal display mode (not inverted)
    ssd1306_cmd(0xAF);

    ssd1306_clear();
    ssd1306_update();
}

void ssd1306_clear(void) { memset(buffer, 0, sizeof(buffer)); }

void ssd1306_update(void)
{
    for (uint8_t page = 0; page < 8; page++) {
        ssd1306_cmd(0xB0 + page);
        ssd1306_cmd(0x00); ssd1306_cmd(0x10);
        for (uint8_t col = 0; col < 128; col++) {
            ssd1306_data(buffer[page * 128 + col]);
        }
    }
}

void ssd1306_draw_string(uint8_t x, uint8_t y, const char *str)
{
    // Rotated 90 degrees to the right
    // Display: 128 wide (X) × 64 tall (Y)
    // Characters are placed horizontally (left to right)
    // Each character runs vertically (top to bottom)
    uint8_t curr_col = x;
    uint8_t start_row = y;
    
    while (*str) {
        uint8_t c = *str++;
        
        // Only render printable ASCII characters (32-126)
        if (c < 32 || c > 126) continue;
        
        // Check if character fits horizontally (8 pixels wide)
        if (curr_col + 8 > 128) {
            break; // No more space horizontally
        }
        
        // Get font data for this character
        uint8_t char_idx = c - 32;
        const uint8_t *char_data = font8x8[char_idx];
        
        // Draw character rotated 90 degrees right (reading top to bottom, left to right)
        // Original font structure: 8 rows × 8 columns
        // After rotation: display left-to-right as rows, top-to-bottom as columns
        for (uint8_t orig_col = 0; orig_col < 8; orig_col++) {
            // For each column in the original font, extract all 8 bits
            uint8_t rotated_byte = 0;
            for (uint8_t orig_row = 0; orig_row < 8; orig_row++) {
                // Get the bit at position (orig_row, orig_col) from font
                uint8_t font_byte = char_data[orig_row];
                uint8_t bit_set = (font_byte >> (7 - orig_col)) & 1;  // Read from right to left
                // After 90° right rotation and reading naturally:
                // orig_row 0 goes to position 0 (top), orig_row 7 goes to position 7 (bottom)
                rotated_byte |= (bit_set << orig_row);
            }
            
            // Write the rotated column as bytes across multiple pages
            uint8_t screen_x = curr_col + orig_col;
            uint8_t screen_y = start_row;
            
            if (screen_x < 128) {
                // Each character is 8 pixels tall
                // May span across multiple 8-pixel pages
                for (uint8_t py = 0; py < 8; py++) {
                    uint8_t y_pos = screen_y + py;
                    if (y_pos < 64) {
                        uint8_t page = y_pos / 8;
                        if (page < 8) {
                            buffer[page * 128 + screen_x] |= rotated_byte;
                        }
                    }
                }
            }
        }
        
        curr_col += 9; // 8 pixels + 1 space between characters
    }
}
